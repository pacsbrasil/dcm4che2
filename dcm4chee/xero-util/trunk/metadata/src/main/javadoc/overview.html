<html>
<head><title>Xero MetaData Framework</title></head>
<body>
<h1>Xero MetaData Framework</h1>

<p>The Xero MetaData Framework is a library that provides multiple ways to declare and use meta-data. 
The intent was to allow meta-data to be both used and declared from a variety of types of components, not just Java.
Further, the intent is to provide a few standard types of uses - a straight name/value use, a list of values use, and
an implementation of the 
<a href="http://www.cs.cmu.edu/afs/cs/project/tinker-arch/www/html/1997/lectures/15.Patterns/base.026.html">pipe-and-filter</a>
 design pattern.</p>
 
 <h2>MetaData</h2>
 <p>For this library, meta-data is defined as the static data used by a class and the connections between classes, 
 including types, list and sets of values chosen.  The preferred type of meta-data to declare is the type of information
 and connections that migh be modified or extended for a given installation or version of the software.  Thus, it is
 convenient to be able to plugin new script libraries to include in a web page, but it is unlikely to be useful to 
 allow changing the choice of the type of list class used internally to sort some set of input numbers provided by a user
 - the difference is that the second choice doesn't contain statically configurable data, but is more implementation
 detail.  This is a bit of a fine line in some cases.  The recommendation is to err on the side of making fewer items
 configurable and then modifying the code to add configuration as required.  This should fairly quicly result in the
 correct set of configuraiton, without making it over-configurable and too difficult to manage.</p>
 
 <h2>Comparison With Other MetaData Libraries/Frameworks</h2>
 <p>Why is yet another meta-data library required?  The answer to that question lies in the goals for this project.
 One goal is to allow MANY types of objects to declare meta-data - JavaScript, XML, Property files, Java tags, JNDI,
 and user extended sources.  Not all of these are likely to be used for a single system/application but it has been
 very convenient to allow declaration in many places.  Another goal is to allow the registered information/objects 
 to be used from many locations - to this end, a simple hierarchical map access type structure has been chosen rather
 than a more complex/structured plugin mechanism.</p>
 
 <h3>Java Tags</h3>
 <p>Java tags are very Java class centric - the primary issue being declaration in non-Java components.</p>
 
 <h3>Spring</h3>
 <p>It appears that Spring is primarily an injection mechanism, not a metadata mechanism.  If someone can suggest 
 how to use Spring for a meta-data mechanism instead of injection and to allow pluggable meta-data declaration types, 
 then Spring might well be a better choice, just to make it more familiar to more users.</p>
 
 <h3>Eclipse Plugin</h3>
 <p>It seems likely that the eclipse plugin mechanism could be extended to allow plugging in additional data types, 
 at least for some plugin points.  However, it wasn't very clear how to do this, and at the point this library was written,
 the server parts for the eclipse plugin were not at all mature, and seemed incompatible with other selected libraries.  
 Again, someone who knows this library well might be able to suggest how to modify Xero to use the Eclipse plugins.
 This would be the first choice selection for an alternative to this library, as other developers likely to use Xero
 are already familiar with the Eclipse plugin mechanism.</p>
 
 <h2>Accessing MetaData</h2>
 <p>The meta-data information is intended to be easily accessed.  To that purpose, there are a couple of access 
 mechanisms designed, in the package {@see org.dcm4chee.xero.metadata.access}.  The first, direct access is through the MetaDataBean object itself.  This is an implementation
 of map, where all child elements are also meta-data objects.  To get the VALUE of an element, use the getValue
 call.  Other mechanisms include a map interface to the values, and an injection mechanism.</p>
 
 <h3>Map Access to Values</h3>
 <p>A simple map mechanism allows access to the values for a single level of meta-data.  This mechanism is the 
 {@see org.dcm4chee.xero.metadata.access.MapWithDefaults}
 See the Javadocs for that class for more details.  This is the recommended access for non-Java values.  It is easy
 to create multi-level values by declaring child-instances of {@see org.dcm4chee.xero.metadata.access.MapWithDefaults}.  An example use is shown below.
 </p>
 
 <pre>
 model=${class:org.dcm4chee.xero.metadata.MapWithDefaults}
 model.a=5
 model.b=B
 model.subMap=${class:org.dcm4chee.xero.metadata.MapWithDefaults}
 </pre>
 
 <p>The above property file definition would create a model that has a child model accessed as "subMap", and the parent model would have 2 other elements,
 a,b with values 5 and B respectively.</p>
 
 <h3>List Access To Values</h3>
 <p>Many objects require a set of list objects.  Two types of lists can be accessed - direct lists of the child
 elements, and a list of the child elements value for a specific element.  For instance, different areas may want to declare
 a script, a stylesheet and some templates to include.  They should be grouped together, so a list of child elements
 of given names is used, something like:
 <pre>
 model.scripts=${class:org.dcm4chee.xero.metadata.list.ValueList}
 model.scripts.childElement=script
 model.area1.script=area1.js
 model.area1.style=area1.css
 model.area2.script=area2.js
 model.area3.style=area3.css
 </pre>
 
 <p><b>TODO</b> Modify the code to extract the setting of the child element in the metadata itself.</p>
 <p>The above code would declare a list name scripts that would contain sibling elements from the metadata,
 for all siblings with a script child element.  The list would contain the VALUES, not the metadata names.</p>
 
 <h2>Providing MetaData</h2>
 <p>It is possible to add additional meta-data information from various sources.  Just implementing the MetaDataProvider 
 interface and then declaring an instance in the meta-data itself will allow extensions of the metadata.  For example:
 <pre>
metaDataProvider.property=${class:org.dcm4chee.xero.metadata.PropertyProvider}
metaDataProvider.property.model=xero-model.metadata
</pre>
declares another meta-data provider to load information from xero-model.metadata.</p>

<h3>Existing MetaData Providers</h3>
<p>See the individual class pages for documentation on how to use these.</p>
<pre>
{@see org.dcm4chee.xero.metadata.PropertyProvider}
{@see org.dcm4chee.xero.metadata.XmlMetaDataProvider}
</pre>
 
 <h2>Providing Values</h2>
 <p>It is possible to add new creator type values to the map by extending the ValueProvider interface.  The design for this is
 that it gets a URL inside ${...} and the URL base name identifies the ValueProvider.  There are already providers for
 ref, class, instance and null.  The provider can register additional child meta-data, and can pre-compute values which
 are then provided to create the final value.  This allows lazy class creation with the class name looked up initially.</p>
 
 <h2>Pipe And Filter</h2>
 <p>See the filter package for some framework components that allow you to use a pipe-and-filter pattern.  Also see the servlet
 package for uses of the pipe-and-filter design that allow implementing an extended pipe and filter mechanism that
 eventually outputs to a servlet response.</p>
 
 </body>
 </html>
