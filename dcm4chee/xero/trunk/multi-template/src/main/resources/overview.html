<html>
<head><title>Overview for Xero multi-template sub-project</title></head>
<body>
<h1>Overview for Xero multi-template sub-project</h1>
<p>The multi-template project is designed to provide a high performance, multi-stage, 
combined client/server templating system.  The are several existing templating systems, so the question is 
why one of these isn't used.  There are a number of objectives to this templating system that make 
existing systems incompatible:</p>
<ol>
<li>XML Based - both input and output should be valid XML, but not necessarily restricted to only XML, that is, another
parser or serializer could be provided to generate/serialize to something else.</li>
<li>Multi-stage - there are quite a few stages of rendering pages that are static across the entire system,
this includes I18N normally, browser independence, local configuration/additions etc.</li>
<li>Extendible with local additions - the pages should be able to be extended with customizations from
localized configurations without having to touch the base templates (for any customizations which are "allowed" - that
is, pre-defined in the existing pages - obviously re-writing the entire application is going to touch entire
pages.)</li>
<li>Mixed client/server - pages should be renderable on either the client or server.  Not necessarily all
stages of all pages can be fully rendered on the client side, for instance, the client may never get
I18N data, but given the partially rendered templates appropriate for the client, it should be able to
render the pages.</li>
<li>Both client and server side usage of XML model data as well as custom object data.</li>
<li>Server side per-page model data.</li>
<li>Use many of the concepts from Tapestry/Maven - configuration by convention instead of by long, complex 
configuration files is quite helpful on both Server/Client sides.</li>
<li>Various stages for pages to be parsed - the INITIAL page view for most pages should be as fully
rendered and as fast (response time) as possible - the makes things appear really fast for the user.</li>
<li>Internal-page renders should be done as much client side as possible - this minimizes server
load and makes it more scaleable.  It also makes the client side response times as independent of network
and server load as is reasonable.  Finally, it allows use of pre-cached, pre-zipped pages to allow minimal 
network transmission size.  </li>
<li>Delta re-render - allow the client (or even server if desired) to re-render based on a delta of 
what has changed rather than re-rendering the entire page all the time.  </li>
<li>Offline client mode - allow the client to pre-fetch all the pages/images for some application and
store them client side to be run fully client side (requires JS enabled client).</li>
<li>Use same templating type process for SUBMISSION of changes, or the processing of said submissions - need
more definition in this area.</li>
<li>Allow the update of pages to flow through the system for fast development.</li>
<li>Maybe have a debug mode that stores line numbers of original source data for faster debugging.
Regardless, having as good debugging messages as possible is very important.</li>
<li>Need to have some validation model that can be used both server/client side - would really like to
integrate this with xforms type definitions if possible.</li>
<li>Client side libraries MUST not take too much startup time - client should appear VERY fast.</li>
</ol>

<h2>How to Replace 1 part of 1 specific template</h2>
<p>In the previous version of the templating design, it was possible to replace 1 specific template used in 
a particular part of the render tree.  This was done by nesting calls and using the pageConfig design.
It would be nice to replicate that as it allows fairly restricted changes to a particular part of the design.
A specific example is the replacing of the output rendering for a table in 2 different ways depending on the
view.  This could also be done by using a ui:param.  That ui:param might be more efficient to replace just
some specific types/display methods in a specific hierarchy.  Alternatively, just over-riding the macro 
definition could also be made to work, and then including a separate definition, perhaps depending on a source
definition.</p>

<h2>How to include templates from another web archive</h2>
<p>If another WAR file had a second set of templates, it could be possible to include multiple levels of
templates, and over-ride specific parts of the templating, as in the previous question, but dynamically instead
of statically.  It would almost certainly be required to start in the second WAR file instead of the first one.
Is it worth doing this?  Another option would be to have some way to parameterize one portion of the query so as
to get a customized version.  It isn't clear yet that both of these are very compatible with each other,
especially in a generic fashion.
The general include could be made to work reasonably easily if it were done as package includes, but it might be hard
to replace a particular child macro in a particular place.  Not quite sure how to manage this yet.
</p>

<h2>How to include specific JS template versions.</h2>
<p>For performance, many template pages need to be loaded as a single, pre-gzipped template, and then templated
on the client.  The pre-gzipping allows a very small number of parameters to define this template set and to get
most of the required templates right up front.  However, for ease of definition, the templates should be included 
one at a time.  Finally, this may interact with over-riding templates for specific version specific instances.
It could be possible to load 2 fairly different template versions, both relying a reasonable sized child template
set - both sets of templates could even be included in 1 file, just under different names.  Some templates used by 
one or the other parent templates could be lazy loaded as well only when needed.
</p>

<h2>Auto child-include of templates</h2>
<p>When one template uses another, by default the child template should be included automatically, and should not
be nested to an indefinite depth, but the parent templates should be re-used unless explicitly over-ridden, the same
way that inheritance of meta-data works.
It is perfectly acceptable to require a new definition of template includes that includes the top level named/nested
template definition.  This can re-use the existing meta-data inheritance mechanism if we can make this work properly.
</p>

<h2>Possible Template Definition</h2>
<pre>
# Adds all the pre-defined initial template definitions to output - this defines output as a multi-stage
# templating system that can produce JS templates, server side render JS free, and server side render initial page display (if any)
output.inherit=multi-template
# Add a single output file - this has individual macros in it
output.output1.tml=output1.tml
output.output1.priority=50

# Now, use output, but add a new output type for "DicomName"
search.output.inherit=output
search.output.DicomName.tml=dicomOutput.tml
search.output.DicomName.priority=25

# Now - how to ensure that the templates don't need to be multiply loaded - it doesn't much matter server
# side, as long as they aren't loaded forever for a long depth first search.  The real issue is to ensure
# that they get loaded client side correctly - note that the above design allows essentially arbitrary includes
# to be added - they could potentially come from another loader.
# On templating, it might be possible to do a redundancy check and only include the nested template if it
# hasn't already been included, and reference anything that has already been included.  This would need to
# be done on a fairly fine grained level - probably at the level of of an individual macro/template.
# One option would be to make a generic object for a template call that always looks up the "right" template to
# use at render time.  This is how the previous design worked, and it seems to be reasonably fast - about 1 us to
# lookup a template by name - the template stack will always have a particular level being used.  This is 
# fairly different from the design of components that are full pre-defined/setup.  It might be possible to mix
# both types - one might be a component, the other a macro, but that leaves the question of when to ever use a 
# macro.
# It is relatively easy to figure out the real path - since the MDB's are re-used, just get the path name
# and the full path name will be a definitive identifier for any given installation.
# Each component usage will require some significant look-ahead determination of which secondary components
# to use, or will require templating time lookup of which component to use - I think doing it at templating
# time is fine.
# It is even fairly easy to determine which next-template any given template comes from, at parse time. 



</pre>

</body>
</html> 