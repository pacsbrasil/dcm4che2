/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is part of dcm4che, an implementation of DICOM(TM) in
 * Java(TM), hosted at http://sourceforge.net/projects/dcm4che.
 *
 * The Initial Developer of the Original Code is
 * Gunter Zeilinger, Huetteldorferstr. 24/10, 1150 Vienna/Austria/Europe.
 * Portions created by the Initial Developer are Copyright (C) 2002-2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * See listed authors below.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
package org.dcm4che2.imageioimpl.plugins.dcm;

import java.awt.image.BufferedImage;
import java.io.Closeable;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.DigestOutputStream;
import java.security.MessageDigest;
import java.util.Formatter;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;

import junit.framework.ComparisonFailure;
import junit.framework.TestCase;

import org.dcm4che2.imageio.plugins.dcm.DicomImageReadParam;

import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGEncodeParam;
import com.sun.image.codec.jpeg.JPEGImageEncoder;

/**
 * Tests for the image reader code. The tests are based on visual inspection.
 * Once the correct test result is found, the SHA-1 hash for the test is
 * recorded. Whenever the output changes, the output should be regenerated by
 * enabling the FileOutputStream in
 * {@link #assertImage(String, String, int, String, DicomImageReadParam)}.
 * 
 * @author rick.riemer
 */
public class DicomImageReaderTest extends TestCase {
    /**
     * Tests the reading of a regular MR instance.
     */
    public void testReadMrAutoWindowing() throws Exception {
        assertImage("mr.dcm", "mr.jpeg", 0,
                "c71635f769acd9194b9f7462d2f2cdec5665eaf0",
                new DicomImageReadParam());
    }

    /**
     * Tests the reading of a regular CT instance, with windowing elements in
     * it's meta data.
     */
    public void testReadCtNoAutoWindowing() throws Exception {
        DicomImageReadParam param = new DicomImageReadParam();
        param.setAutoWindowing(false);
        assertImage("ct.dcm", "ct.jpeg", 0,
                "3271ebebe62c5b7cf569fc33dfd594ea65fa6d8e", param);
    }

    /**
     * Tests the reading of a regular CT instance, with windowing elements in
     * it's meta data, but with a custom Window Center and Window Width set on
     * the reader parameters.
     * <p>
     * <em>Note for visual inspection: since we set the Window Width to a small
     * value, the rendered output should be clearly distinct from
     * {@link #testReadCtNoAutoWindowing()}.</em>
     */
    public void notTestReadCtApplyCustomWindow() throws Exception {
        // TODO 2007-11-23 rick.riemer Re-enable test once we know what the
        // expected output for this test should be.
        DicomImageReadParam param = new DicomImageReadParam();
        param.setAutoWindowing(false);
        param.setWindowCenter(10);
        param.setWindowWidth(100);

        assertImage("ct.dcm", "ct-customwindow.jpeg", 0,
                "3f60d107c808ba721e963f0f25ef1adcadd26819", param);
    }

    /**
     * Tests the reading of an arbitrary frame from a multi-frame instance. In
     * this case an Enhanced CT from the test set from <a
     * href="ftp://medical.nema.org/MEDICAL/Dicom/Multiframe/">the DICOM
     * standard FTP server</a>.
     * <p>
     * <em>NOTE for visual inspection: frame 1 should be returned, which is a front
     * view of a chest. If you see a side view, you're looking at the wrong
     * frame (0).</em>
     */
    public void testReadMultiframe() throws Exception {
        assertImage("ct-multiframe.dcm", "ct-multiframe-frame2.jpeg", 1,
                "03b49a92a804d54250632d1d92ecee9fcb27cb4a",
                new DicomImageReadParam());
    }

    /**
     * Tests the reading of a CR instance, with MONOCHROME1 photometric
     * interpretation, with Window Center and Window With elements.
     */
    public void testReadMonochrome1() throws Exception {
        assertImage("cr-monochrome1.dcm", "cr-monochrome1.jpeg", 0,
                "3f60d107c808ba721e963f0f25ef1adcadd26819",
                new DicomImageReadParam());
    }

    /**
     * Tests the reading of a CR instance, with MONOCHROME1 photometric
     * interpretation, <em>without</em> Window Center and Window With
     * elements.
     */
    public void testReadMonochrome1NoWindow() throws Exception {
        assertImage("cr-monochrome1-nowindow.dcm",
                "cr-monochrome1-nowindow.jpeg", 0,
                "91c7da974af97c49586a3140f5f3766876ddf0b3",
                new DicomImageReadParam());
    }

    /**
     * Tests the reading of a CR instance, with MONOCHROME1 photometric
     * interpretation, <em>without</em> Window Center and Window With
     * elements, but with a custom Window Center and Window Width set on the
     * reader parameters.
     * <p>
     * <em>Note for visual inspection: since we set the Window Center and
     * Window Width to the same values as the instance used in
     * {@link #testReadMonochrome1()}, the output (and thus the hash) is
     * expected to be the same.</em>
     */
    // TODO 2007-11-23 rick.riemer Re-enable test once we know what the expected
    // output for this test should be.
    public void notTestReadMonochrome1ApplyCustomWindow() throws Exception {
        DicomImageReadParam param = new DicomImageReadParam();
        param.setAutoWindowing(false);
        param.setWindowCenter(10000);
        param.setWindowWidth(27000);

        assertImage("cr-monochrome1-nowindow.dcm",
                "cr-monochrome1-nowindow-customwindow.jpeg", 0,
                "3f60d107c808ba721e963f0f25ef1adcadd26819", param);
    }

    /**
     * Tests the reading of instances from the IHE MESA Modality LUT test cases.
     * It is expected that the hashes for all output are the same.
     * <p>
     * <em>Note for visual inspection: all images should produce the same test
     * pattern</em>.
     */
    // TODO 2007-11-23 rick.riemer Re-enable after
    // http://www.dcm4che.org/jira/browse/DCM-145 gets resolved.
    public void notTestMLUT() throws Exception {
        boolean failed = false;
        for (int i = 0; i < 19; ++i) {
            String imgNumber = String.format("%02d", Integer.valueOf(i + 1));
            try {
                assertImage("mlut_" + imgNumber + ".dcm", "mlut" + imgNumber
                        + ".jpeg", 0,
                        "b712a97da4b95f61e67b9c46ff82b8f96551834b",
                        new DicomImageReadParam());
            } catch (ComparisonFailure e) {
                System.err.println("MLUT " + imgNumber + " failure: "
                        + e.getMessage());
                failed = true;
            }
        }

        if (failed) {
            fail("one or more MLUT instances failed. see stderr for details.");
        }
    }

    @SuppressWarnings("unused")
    public void assertImage(String resourceLocation, String jpegFilename,
            int frameNumber, String expectedHash, DicomImageReadParam param)
            throws Exception {
        // OutputStream os = new FileOutputStream(jpegFilename);
        OutputStream os = new NullOutputStream();
        InputStream is = null;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            DigestOutputStream dos = new DigestOutputStream(os, digest);
            is = DicomImageReaderTest.class
                    .getResourceAsStream(resourceLocation);
            assertNotNull(is);
            dcm2jpeg(is, dos, frameNumber, param);
            String hash = formatDigest(digest);

            // NOTE: If the hash check fails, regenerate the JPEG by using the
            // FileOutputStream above, and check it visually. Use a new hash
            // only if the new JPEG is OK.
            assertEquals(expectedHash, hash);
        } finally {
            safeClose(is);
            safeClose(os);
        }
    }

    private void dcm2jpeg(InputStream dcmStream, OutputStream jpegStream,
            int frameNumber, DicomImageReadParam param)
            throws FileNotFoundException, IOException {
        DicomImageReaderSpi spi = new DicomImageReaderSpi();
        DicomImageReader reader = (DicomImageReader) spi
                .createReaderInstance(null);

        ImageInputStream iis = null;
        try {
            iis = ImageIO.createImageInputStream(dcmStream);

            reader.setInput(iis, true);
            BufferedImage image = reader.read(frameNumber, param);

            // we use a com.sun class here, since the regular Image I/O JPEG
            // encoder doesn't support high bit rates.
            JPEGEncodeParam encodeParam = JPEGCodec
                    .getDefaultJPEGEncodeParam(image);
            encodeParam.setQuality(1.0f, false);
            JPEGImageEncoder enc = JPEGCodec.createJPEGEncoder(jpegStream);
            enc.encode(image);
        } finally {
            safeClose(iis);
            safeClose(jpegStream);
        }
    }

    private void safeClose(ImageInputStream iis) throws IOException {
        if (iis != null) {
            iis.close();
        }
    }

    private void safeClose(Closeable obj) throws IOException {
        if (obj != null) {
            obj.close();
        }
    }

    public static String formatDigest(MessageDigest digest) {
        StringBuilder result = new StringBuilder();
        Formatter formatter = new Formatter(result);
        for (byte b : digest.digest()) {
            formatter.format("%02x", Byte.valueOf(b));
        }
        return result.toString();
    }
}
